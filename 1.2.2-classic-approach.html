<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <!-- Your GitHub stylesheet -->
    <link rel="stylesheet" href="assets/github.css" />

    <!-- Your custom layout -->
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        background-color: #0d1117;
      }

      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        width: 100%;
        padding: 45px;
      }

      /* Optional: nicer TOC spacing */
      nav.toc {
        margin-bottom: 2.5rem;
        padding-bottom: 1.5rem;
        border-bottom: 1px solid #30363d;
      }
    </style>

    <!-- Pandoc syntax highlighting CSS -->
        <style type="text/css">
      html { -webkit-text-size-adjust: 100%; }
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
        }
      pre.numberSource { margin-left: 3em;  padding-left: 4px; }
      div.sourceCode
        { color: #cccccc; background-color: #303030; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ffcfaf; } /* Alert */
      code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #dca3a3; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #f0dfaf; } /* ControlFlow */
      code span.ch { color: #dca3a3; } /* Char */
      code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
      code span.co { color: #7f9f7f; } /* Comment */
      code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
      code span.do { color: #7f9f7f; } /* Documentation */
      code span.dt { color: #dfdfbf; } /* DataType */
      code span.dv { color: #dcdccc; } /* DecVal */
      code span.er { color: #c3bf9f; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #c0bed1; } /* Float */
      code span.fu { color: #efef8f; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
      code span.kw { color: #f0dfaf; } /* Keyword */
      code span.op { color: #f0efd0; } /* Operator */
      code span.ot { color: #efef8f; } /* Other */
      code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
      code span.sc { color: #dca3a3; } /* SpecialChar */
      code span.ss { color: #cc9393; } /* SpecialString */
      code span.st { color: #cc9393; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #cc9393; } /* VerbatimString */
      code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
    </style>
      </head>

  <body>
    <article class="markdown-body">
       <h3 data-number="1.2.2" id="classic-approach">Classic
Approach</h3>
<p>Before diving into <strong>Transit</strong>, letâ€™s first look at how
state machines are typically implemented in PureScript using pattern
matching. This classic approach is familiar to most PureScript
developers and serves as a baseline for understanding what
<strong>Transit</strong> improves upon.</p>
<h4 data-number="1.2.2.1" id="states-and-message-types">States and
Message types</h4>
<p>To represent our door in code, we need two major types: the states
the door can be in, and the actions that can change those states. In
PureScript, we define these as simple data types. We are using the
suffix <code>D</code> to denote the traditional approach (D = data).</p>
<!-- PD_START:purs
filePath: test/Examples/DoorSimple.purs
pick:
  - StateD
  - MsgD
-->
<div class="sourceCode" id="cb1"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StateD</span> <span class="ot">=</span> <span class="dt">DoorOpen</span> <span class="op">|</span> <span class="dt">DoorClosed</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MsgD</span> <span class="ot">=</span> <span class="dt">Close</span> <span class="op">|</span> <span class="dt">Open</span></span></code></pre></div>
<p align="right">
<sup
    >ðŸ—Ž <a href="test/Examples/DoorSimple.purs#L27-L29"
      >test/Examples/DoorSimple.purs L27-L29</a
    > </sup>
</p>
<!-- PD_END -->
<p>The <code>State</code> type captures the two possible states we saw
in the diagram: <code>DoorOpen</code> and <code>DoorClosed</code>. The
<code>Msg</code> type represents the two actions: <code>Close</code> and
<code>Open</code>. These correspond directly to what we visualized
earlier â€” each state and each transition from the diagram has a
corresponding value in these types.</p>
<h4 data-number="1.2.2.2" id="the-update-function">The update
function</h4>
<p>Now that we have our types, we need a function that takes the current
state and a message, and returns the new state. The traditional way to
implement this is with a pattern-matching function:</p>
<!-- PD_START:purs
filePath: test/Examples/DoorSimple.purs
pick:
  - updateD
-->
<div class="sourceCode" id="cb2"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateD ::</span> <span class="dt">StateD</span> <span class="ot">-&gt;</span> <span class="dt">MsgD</span> <span class="ot">-&gt;</span> <span class="dt">StateD</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>updateD state msg <span class="ot">=</span> <span class="kw">case</span> state, msg <span class="kw">of</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DoorOpen</span>, <span class="dt">Close</span> <span class="ot">-&gt;</span> <span class="dt">DoorClosed</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DoorClosed</span>, <span class="dt">Open</span> <span class="ot">-&gt;</span> <span class="dt">DoorOpen</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  _, _ <span class="ot">-&gt;</span> state</span></code></pre></div>
<p align="right">
<sup
    >ðŸ—Ž <a href="test/Examples/DoorSimple.purs#L31-L35"
      >test/Examples/DoorSimple.purs L31-L35</a
    > </sup>
</p>
<!-- PD_END -->
<p>We pattern match on both the current state and the message at once.
It could also be written as a nested pattern match.</p>
<p>This function handles the two valid transitions we saw in the
diagram: closing an open door and opening a closed door. The catch-all
case <code>_, _ -&gt; state</code> handles any invalid combinations
(like trying to open an already open door) by returning the current
state unchanged.</p>
<p>While this approach works and is straightforward, it has some
drawbacks:</p>
<ul>
<li><p><strong>Implicit state machine specification</strong>: The state
machineâ€™s structure is only defined implicitly within the update
functionâ€™s pattern matching and return values.</p></li>
<li><p><strong>Documentation drift</strong>: If you maintain a state
diagram for documentation purposes, thereâ€™s nothing ensuring the code
stays in sync â€” you have to remember to update both manually.</p></li>
<li><p><strong>Limited analysis capabilities</strong>: Thereâ€™s no way to
analyze the state machineâ€™s structure or behavior statically â€” you can
only understand it by running the code.</p></li>
</ul>     </article>
  </body>
</html>
