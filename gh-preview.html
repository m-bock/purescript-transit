<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Your GitHub stylesheet -->
    <link rel="stylesheet" href="assets/github.css" />

    <!-- Your custom layout -->
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        background-color: #0d1117;
      }

      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        width: 100%;
        padding: 45px;
      }

      /* Optional: nicer TOC spacing */
      nav.toc {
        margin-bottom: 2.5rem;
        padding-bottom: 1.5rem;
        border-bottom: 1px solid #30363d;
      }
    </style>

    <!-- Pandoc syntax highlighting CSS -->
        <style type="text/css">
      html { -webkit-text-size-adjust: 100%; }
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
        }
      pre.numberSource { margin-left: 3em;  padding-left: 4px; }
      div.sourceCode
        { color: #cccccc; background-color: #303030; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ffcfaf; } /* Alert */
      code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #dca3a3; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #f0dfaf; } /* ControlFlow */
      code span.ch { color: #dca3a3; } /* Char */
      code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
      code span.co { color: #7f9f7f; } /* Comment */
      code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
      code span.do { color: #7f9f7f; } /* Documentation */
      code span.dt { color: #dfdfbf; } /* DataType */
      code span.dv { color: #dcdccc; } /* DecVal */
      code span.er { color: #c3bf9f; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #c0bed1; } /* Float */
      code span.fu { color: #efef8f; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
      code span.kw { color: #f0dfaf; } /* Keyword */
      code span.op { color: #f0efd0; } /* Operator */
      code span.ot { color: #efef8f; } /* Other */
      code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
      code span.sc { color: #dca3a3; } /* SpecialChar */
      code span.ss { color: #cc9393; } /* SpecialString */
      code span.st { color: #cc9393; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #cc9393; } /* VerbatimString */
      code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
    </style>
      </head>

  <body>
    <article class="markdown-body">
       <p><strong>Table of Contents</strong></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#transit">Transit</a>
<ul>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#about-this-documentation">About This
Documentation</a></li>
<li><a href="#installation">Installation</a></li>
</ul></li>
<li><a href="#example-1-a-simple-door">Example 1: A Simple Door</a>
<ul>
<li><a href="#the-state-machine">The State Machine</a></li>
<li><a href="#classic-approach">Classic Approach</a></li>
<li><a href="#transit-approach">Transit Approach</a></li>
<li><a href="#testing-the-update-function">Testing the update
function</a></li>
<li><a href="#state-diagram-and-transition-table-generation">State
Diagram and Transition Table Generation</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="transit">Transit</h1>
<h2 id="introduction">Introduction</h2>
<p><strong>Transit</strong> is a PureScript library for building
type-safe state machines. It provides a type-level DSL for specifying
state transitions. You define your state machine once using this
specification, and the compiler ensures your implementation matches it ‚Äî
eliminating bugs from invalid transitions, missing cases, or
documentation drift.</p>
<blockquote>
<p>If you‚Äôre familiar with Servant[^servant] from Haskell,
<strong>Transit</strong> follows a similar philosophy: just as Servant
uses a REST API type-level specification to ensure type-safe routing
functions and generate OpenAPI documentation, <strong>Transit</strong>
uses a state machine graph type-level specification to ensure type-safe
update functions and generate state diagrams.</p>
</blockquote>
<h3 id="about-this-documentation">About This Documentation</h3>
<p>All code examples in this documentation are extracted from actual,
type-checked PureScript source files. Also, whenever you find an
assertion or a full unit test, it‚Äôs ensured that it ran and passed. In
this sense this text is not just documentation, but also a test suite.
At the bottom of every code example you can find a link to the actual
source file. So you can get a better picture of the context and get
information about the imports used.</p>
<p><strong>Terminology note</strong>: Throughout this documentation, the
terms <em>message</em>, <em>action</em>, and <em>transition</em> are
used interchangeably to refer to the events that trigger state
changes[^terminology]. In <strong>Transit</strong>‚Äôs type system, these
correspond to the message types in your <code>Msg</code> variant.</p>
<h3 id="installation">Installation</h3>
<h2 id="example-1-a-simple-door">Example 1: A Simple Door</h2>
<blockquote>
<p>Full source code: <em><a
href="test/Examples/Door.purs">test/Examples/Door.purs</a></em></p>
</blockquote>
<p><img src="../assets/header-door.png" width="450" /></p>
<p>Let‚Äôs start with a simple door state machine to demonstrate
<strong>Transit</strong>‚Äôs core concepts. This example will show you how
to define a state machine using <strong>Transit</strong>‚Äôs type-level
DSL, implement a type-safe update function, and generate documentation
automatically. We‚Äôll compare the traditional approach with
<strong>Transit</strong>‚Äôs approach to highlight the benefits of the
latter.</p>
<h3 id="the-state-machine">The State Machine</h3>
<p>Think of a door that can be either open or closed. When it‚Äôs open,
you can close it. When it‚Äôs closed, you can open it. That‚Äôs it ‚Äî no
other actions make sense. You can‚Äôt open a door that‚Äôs already open, and
you can‚Äôt close a door that‚Äôs already closed. This simple behavior is
what we‚Äôre modeling here.</p>
<p>Before diving into the code, let‚Äôs visualize our simple door state
machine. This will help you understand the structure we‚Äôre about to
implement.</p>
<h4 id="state-diagram">State Diagram</h4>
<p>The state diagram below shows all possible states and the valid
transitions between them:</p>
<p><picture>
<source media="(prefers-color-scheme: dark)" srcset="renders/door-dark.svg">
<source media="(prefers-color-scheme: light)" srcset="renders/door-light.svg">
<img alt="Simple Door state diagram" src="renders/door-light.svg">
</picture></p>
<p>In this diagram, you can see:</p>
<ul>
<li><strong>Two states</strong>: <code>DoorOpen</code> and
<code>DoorClosed</code> (shown as rectangles)</li>
<li><strong>Two transitions</strong>: The <code>Close</code> transition
moves from <code>DoorOpen</code> to <code>DoorClosed</code>, and the
<code>Open</code> transition moves from <code>DoorClosed</code> to
<code>DoorOpen</code></li>
<li><strong>Arrows</strong>: The direction of each arrow shows which
state changes are valid</li>
</ul>
<h4 id="transition-table">Transition Table</h4>
<p>For a more structured view, here‚Äôs the corresponding transition
table:</p>
<!-- PD_START:raw
filePath: renders/door.md
wrapNl: true
-->
<table>
<thead>
<tr>
<th>State</th>
<th></th>
<th>Message</th>
<th></th>
<th>State</th>
</tr>
</thead>
<tbody>
<tr>
<td>DoorOpen</td>
<td><strong>‚ü∂</strong></td>
<td>Close</td>
<td><strong>‚ü∂</strong></td>
<td>DoorClosed</td>
</tr>
<tr>
<td>DoorClosed</td>
<td><strong>‚ü∂</strong></td>
<td>Open</td>
<td><strong>‚ü∂</strong></td>
<td>DoorOpen</td>
</tr>
</tbody>
</table>
<!-- PD_END -->
<p>Each row shows one valid transition: which state you start in, which
action you take, and which state you end up in. Notice that invalid
actions ‚Äî like trying to open an already open door ‚Äî simply don‚Äôt appear
in the table.</p>
<p>Now let‚Äôs see how we represent this in PureScript code.</p>
<h3 id="classic-approach">Classic Approach</h3>
<p>Before diving into <strong>Transit</strong>, let‚Äôs first look at how
state machines are typically implemented in PureScript using pattern
matching. This classic approach is familiar to most PureScript
developers and serves as a baseline for understanding what
<strong>Transit</strong> improves upon.</p>
<h4 id="states-and-message-types">States and Message types</h4>
<p>To represent our door in code, we need two major types: the states
the door can be in, and the actions that can change those states. In
PureScript, we define these as simple data types. We are using the
suffix <code>D</code> to denote the traditional approach (D = data).</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - StateD
  - MsgD
-->
<div class="sourceCode" id="cb1"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StateD</span> <span class="ot">=</span> <span class="dt">DoorOpen</span> <span class="op">|</span> <span class="dt">DoorClosed</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MsgD</span> <span class="ot">=</span> <span class="dt">Close</span> <span class="op">|</span> <span class="dt">Open</span></span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L27-L29"
      >test/Examples/Door.purs L27-L29</a
    > </sup>
</p>
<!-- PD_END -->
<p>The <code>State</code> type captures the two possible states we saw
in the diagram: <code>DoorOpen</code> and <code>DoorClosed</code>. The
<code>Msg</code> type represents the two actions: <code>Close</code> and
<code>Open</code>. These correspond directly to what we visualized
earlier ‚Äî each state and each transition from the diagram has a
corresponding value in these types.</p>
<h4 id="the-update-function">The update function</h4>
<p>Now that we have our types, we need a function that takes the current
state and a message, and returns the new state. The traditional way to
implement this is with a pattern-matching function:</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - updateD
-->
<div class="sourceCode" id="cb2"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateD ::</span> <span class="dt">StateD</span> <span class="ot">-&gt;</span> <span class="dt">MsgD</span> <span class="ot">-&gt;</span> <span class="dt">StateD</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>updateD state msg <span class="ot">=</span> <span class="kw">case</span> state, msg <span class="kw">of</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DoorOpen</span>, <span class="dt">Close</span> <span class="ot">-&gt;</span> <span class="dt">DoorClosed</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DoorClosed</span>, <span class="dt">Open</span> <span class="ot">-&gt;</span> <span class="dt">DoorOpen</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  _, _ <span class="ot">-&gt;</span> state</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L31-L35"
      >test/Examples/Door.purs L31-L35</a
    > </sup>
</p>
<!-- PD_END -->
<p>We pattern match on both the current state and the message at once.
It could also be written as a nested pattern match.</p>
<p>This function handles the two valid transitions we saw in the
diagram: closing an open door and opening a closed door. The catch-all
case <code>_, _ -&gt; state</code> handles any invalid combinations
(like trying to open an already open door) by returning the current
state unchanged.</p>
<p>While this approach works and is straightforward, it has some
drawbacks:</p>
<ul>
<li><p><strong>Implicit state machine specification</strong>: The state
machine‚Äôs structure is only defined implicitly within the update
function‚Äôs pattern matching and return values.</p></li>
<li><p><strong>Documentation drift</strong>: If you maintain a state
diagram for documentation purposes, there‚Äôs nothing ensuring the code
stays in sync ‚Äî you have to remember to update both manually.</p></li>
<li><p><strong>Limited analysis capabilities</strong>: There‚Äôs no way to
analyze the state machine‚Äôs structure or behavior statically ‚Äî you can
only understand it by running the code.</p></li>
</ul>
<h3 id="transit-approach">Transit Approach</h3>
<p>With the <strong>Transit</strong> library, we take a different
approach that addresses the drawbacks of the classic method. Instead of
writing the update function directly, we first define a type-level
specification that describes our state machine. This specification
serves as a single source of truth that the compiler can verify against
your implementation.</p>
<h4 id="the-type-level-specification">The Type-Level Specification</h4>
<p>First, we define the state machine structure using
<strong>Transit</strong>‚Äôs type-level DSL:</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - DoorTransit
-->
<div class="sourceCode" id="cb3"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">DoorTransit</span> <span class="ot">=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Transit</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">:*</span> (<span class="st">&quot;DoorOpen&quot;</span> <span class="op">:@</span> <span class="st">&quot;Close&quot;</span> <span class="op">&gt;|</span> <span class="st">&quot;DoorClosed&quot;</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">:*</span> (<span class="st">&quot;DoorClosed&quot;</span> <span class="op">:@</span> <span class="st">&quot;Open&quot;</span> <span class="op">&gt;|</span> <span class="st">&quot;DoorOpen&quot;</span>)</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L51-L54"
      >test/Examples/Door.purs L51-L54</a
    > </sup>
</p>
<!-- PD_END -->
<p>Breaking down the syntax:</p>
<ul>
<li><code>Transit</code> initializes an empty transition list</li>
<li><code>:*</code> is an infix operator that appends each transition to
the list</li>
<li><code>"DoorOpen" :@ "Close" &gt;| "DoorClosed"</code> means: in
state <code>DoorOpen</code>, when receiving message <code>Close</code>,
transition to state <code>DoorClosed</code></li>
<li>The <code>@</code> operator connects a state to a message, and
<code>&gt;|</code> indicates the target state</li>
</ul>
<p>This type-level specification fully defines the state machine‚Äôs
structure. The compiler can now use this specification to ensure our
implementation is correct.</p>
<h4 id="state-and-message-types">State and Message Types</h4>
<p><strong>Transit</strong> uses <code>Variant</code> types (from
<code>purescript-variant</code>)[^variant] for both <code>State</code>
and <code>Msg</code> instead of traditional ADTs. Variants are open sum
types where each constructor is labeled with a type-level symbol (like
<code>"DoorOpen"</code> or <code>"Close"</code>).</p>
<p>This design choice is crucial for <strong>Transit</strong>‚Äôs
type-level machinery. The key advantage is that <strong>Transit</strong>
can filter the possible cases (both input states/messages and output
states) for each handler function. Variants are perfect for this. There
is no way to express a subset of cases from a traditional ADT.</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - State
  - Msg
-->
<div class="sourceCode" id="cb4"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Variant</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  ( <span class="st">&quot;DoorOpen&quot;</span><span class="ot"> ::</span> {}</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  , <span class="st">&quot;DoorClosed&quot;</span><span class="ot"> ::</span> {}</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Msg</span> <span class="ot">=</span> <span class="dt">Variant</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  ( <span class="st">&quot;Close&quot;</span><span class="ot"> ::</span> {}</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  , <span class="st">&quot;Open&quot;</span><span class="ot"> ::</span> {}</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L41-L49"
      >test/Examples/Door.purs L41-L49</a
    > </sup>
</p>
<!-- PD_END -->
<h4 id="the-update-function-1">The Update Function</h4>
<p>Based on this specification, we create an update function using
<code>mkUpdate</code>:</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - update
-->
<div class="sourceCode" id="cb5"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">update ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">State</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>update <span class="ot">=</span> mkUpdate <span class="op">@</span><span class="dt">DoorTransit</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  (match <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span> <span class="op">@</span><span class="st">&quot;Close&quot;</span> \_ _ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">@</span><span class="st">&quot;DoorClosed&quot;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  (match <span class="op">@</span><span class="st">&quot;DoorClosed&quot;</span> <span class="op">@</span><span class="st">&quot;Open&quot;</span> \_ _ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span>)</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L56-L59"
      >test/Examples/Door.purs L56-L59</a
    > </sup>
</p>
<!-- PD_END -->
<p>Here‚Äôs how this works:</p>
<ul>
<li><p><code>mkUpdate @DoorTransit</code> creates an update
function based on the <code>DoorTransit</code> specification. The
<code>@</code> symbol is type application[^type-app], passing the
specification to the function.</p></li>
<li><p>Each <code>match</code> line handles one transition from the
specification. The first two arguments (<code>@"DoorOpen"</code> and
<code>@"Close"</code>) are type-level symbols (type applications) that
specify which state and message to match on. The lambda function defines
what happens when that transition occurs.</p></li>
<li><p><code>return @"DoorClosed"</code> specifies which state to
transition to. The <code>return</code> function is part of
<strong>Transit</strong>‚Äôs DSL for specifying the target state, and the
<code>@</code> symbol again indicates a type-level symbol.</p></li>
<li><p><strong>Important</strong>: The order of match handlers must
match the order of transitions in the DSL specification. In this
example, the handlers are provided in the same order as they appear in
<code>DoorTransit</code>: <code>DoorOpen :@ Close</code>, then
<code>DoorClosed :@ Open</code>.</p></li>
</ul>
<h4 id="how-this-solves-the-classic-approachs-problems">How This Solves
the Classic Approach‚Äôs Problems</h4>
<p>This approach addresses all the drawbacks we saw earlier:</p>
<ul>
<li><p><strong>Explicit state machine specification</strong>: The state
machine‚Äôs structure is defined explicitly in the type-level DSL. This
specification serves as a single source of truth that is accessible for
various purposes.</p></li>
<li><p><strong>No documentation drift</strong>: Documentation such as
state diagrams and transition tables can be generated directly from the
specification, ensuring they always stay in sync with the code.</p></li>
<li><p><strong>Static analysis capabilities</strong>: The specification
can be converted into a graph data structure, enabling sophisticated
static analysis of the state machine‚Äôs properties without running the
code.</p></li>
</ul>
<h3 id="testing-the-update-function">Testing the update function</h3>
<p><img src="../assets/locomotive-test-run.jpg" width="450" /></p>
<p>Before we move further, let‚Äôs actually verify that our implementation
of the update function works as we expect it to. We‚Äôll do this by
writing some tests.</p>
<h4 id="creating-variant-values">Creating Variant Values</h4>
<p>To create values of type <code>Variant</code>,
<strong>Transit</strong> provides the <code>v</code> function from
<code>Transit.VariantUtils</code>. It‚Äôs a convenience wrapper around
<code>Variant</code>‚Äôs <code>inj</code> function that uses type
application (no Proxy needed) and allows omitting empty record
arguments:</p>
<ul>
<li><p>Transit record payload (argument can be omitted)</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span><span class="ot"> ::</span> <span class="dt">State</span></span></code></pre></div></li>
<li><p>Non-empty payload (must provide the data)</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>v <span class="op">@</span><span class="st">&quot;DoorLocked&quot;</span> { activePin<span class="op">:</span> <span class="st">&quot;1234&quot;</span> }<span class="ot"> ::</span> <span class="dt">State</span></span></code></pre></div></li>
</ul>
<p>This is more ergonomic than using
<code>V.inj (Proxy :: _ "DoorOpen") {}</code> directly.</p>
<h4 id="testing-state-transitions">Testing State Transitions</h4>
<p>To test our update function, we‚Äôll use two useful functions from the
<code>Data.Array</code> module:</p>
<!-- PD_START:purs
inline: true
pick:
  - tag: signature_or_foreign
    name: foldl
    filePath: .spago/p/arrays-7.3.0/src/Data/Array.purs
    prefix: '- '
  - tag: signature_or_foreign
    name: scanl
    filePath: .spago/p/arrays-7.3.0/src/Data/Array.purs
    prefix: '- '
split: true
-->
<ul>
<li><code>foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Array a -&gt; b</code></li>
<li><code>scanl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Array a -&gt; Array b</code></li>
</ul>
<!-- PD_END -->
<p>The simplest way to test the update function is to use
<code>foldl</code> to apply a sequence of messages and check if the
final state matches what we expect:</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - tag: value
    name: assert1
-->
<div class="sourceCode" id="cb8"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>assert1 <span class="ot">=</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldl</span> update (v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span>) [ v <span class="op">@</span><span class="st">&quot;Close&quot;</span>, v <span class="op">@</span><span class="st">&quot;Open&quot;</span>, v <span class="op">@</span><span class="st">&quot;Close&quot;</span> ]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">`shouldEqual`</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      (v <span class="op">@</span><span class="st">&quot;DoorClosed&quot;</span>)</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L66-L69"
      >test/Examples/Door.purs L66-L69</a
    > </sup>
</p>
<!-- PD_END -->
<p>This test starts with the door open, closes it, opens it, then closes
it again. It checks that we end up with the door closed, as
expected.</p>
<p>This test only checks the final result. To be more thorough, we
should also verify that each step along the way works correctly. The
<code>scanl</code> function is perfect for this ‚Äî it shows us all the
intermediate states, not just the final one.</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - tag: value
    name: assert2
-->
<div class="sourceCode" id="cb9"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>assert2 <span class="ot">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scanl</span> update (v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span>) [ v <span class="op">@</span><span class="st">&quot;Close&quot;</span>, v <span class="op">@</span><span class="st">&quot;Open&quot;</span>, v <span class="op">@</span><span class="st">&quot;Close&quot;</span> ]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">`shouldEqual`</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      [ v <span class="op">@</span><span class="st">&quot;DoorClosed&quot;</span>, v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span>, v <span class="op">@</span><span class="st">&quot;DoorClosed&quot;</span> ]</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L72-L75"
      >test/Examples/Door.purs L72-L75</a
    > </sup>
</p>
<!-- PD_END -->
<p>This test does the same thing ‚Äî starts with the door open, closes it,
opens it, then closes it again. But instead of just checking the final
result, it verifies each step along the way: after closing, the door is
closed; after opening, the door is open; and after closing again, the
door is closed. This makes sure each transition works correctly.</p>
<p>Since we‚Äôll want to write more of these tests for further examples,
it‚Äôs helpful to define a reusable helper function. The
<code>assertWalk</code> function takes an update function, an initial
state, and a list of message/state pairs representing the expected walk
through the state machine:</p>
<!-- PD_START:purs
filePath: test/Examples/Common.purs
pick:
  - assertWalk
-->
<div class="sourceCode" id="cb10"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>assertWalk</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> msg state</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">.</span> <span class="dt">Eq</span> state</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Show</span> state</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (state <span class="ot">-&gt;</span> msg <span class="ot">-&gt;</span> state)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> state</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Array</span> (msg <span class="op">/</span>\ state)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Aff</span> <span class="dt">Unit</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>assertWalk updateFn initState walk <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    msgs ::</span> <span class="dt">Array</span> msg</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    msgs <span class="ot">=</span> <span class="fu">map</span> <span class="fu">fst</span> walk</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    expectedStates ::</span> <span class="dt">Array</span> state</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    expectedStates <span class="ot">=</span> <span class="fu">map</span> <span class="fu">snd</span> walk</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    actualStates ::</span> <span class="dt">Array</span> state</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    actualStates <span class="ot">=</span> <span class="fu">scanl</span> updateFn initState msgs</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  actualStates <span class="ot">`shouldEqual`</span> expectedStates</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Common.purs#L40-L59"
      >test/Examples/Common.purs L40-L59</a
    > </sup>
</p>
<!-- PD_END -->
<p>The function extracts the messages from the pairs, applies them
sequentially using <code>scanl</code>, and verifies that the resulting
states match the expected ones. Here‚Äôs how we use it:</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - tag: value
    name: assert3
-->
<div class="sourceCode" id="cb11"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>assert3 <span class="ot">=</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  assertWalk update</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    (v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    [ v <span class="op">@</span><span class="st">&quot;Close&quot;</span> <span class="op">~&gt;</span> v <span class="op">@</span><span class="st">&quot;DoorClosed&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    , v <span class="op">@</span><span class="st">&quot;Open&quot;</span> <span class="op">~&gt;</span> v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    , v <span class="op">@</span><span class="st">&quot;Close&quot;</span> <span class="op">~&gt;</span> v <span class="op">@</span><span class="st">&quot;DoorClosed&quot;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    , v <span class="op">@</span><span class="st">&quot;Close&quot;</span> <span class="op">~&gt;</span> v <span class="op">@</span><span class="st">&quot;DoorClosed&quot;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    , v <span class="op">@</span><span class="st">&quot;Open&quot;</span> <span class="op">~&gt;</span> v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    , v <span class="op">@</span><span class="st">&quot;Open&quot;</span> <span class="op">~&gt;</span> v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    , v <span class="op">@</span><span class="st">&quot;Open&quot;</span> <span class="op">~&gt;</span> v <span class="op">@</span><span class="st">&quot;DoorOpen&quot;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L78-L88"
      >test/Examples/Door.purs L78-L88</a
    > </sup>
</p>
<!-- PD_END -->
<p>The <code>~&gt;</code> operator is an infix alias for
<code>Tuple</code>. So <code>v @"Close" ~&gt; v @"DoorClosed"</code> is
equivalent to <code>Tuple (v @"Close") (v @"DoorClosed")</code>.</p>
<p>We read it like: Starting from state <code>DoorOpen</code>, when
receiving message <code>Close</code>, we expect the next state to be
<code>DoorClosed</code>. From there, when receiving message
<code>Open</code>, we expect the next state to be <code>DoorOpen</code>.
And so on.</p>
<h3 id="state-diagram-and-transition-table-generation">State Diagram and
Transition Table Generation</h3>
<p><img src="../assets/printing-office.png" width="550" /></p>
<p><strong>Transit</strong> can generate both state diagrams and
transition tables directly from your type-level specification. Both
generation processes use the same approach: <code>reflectType</code>
converts your type-level DSL specification to a term-level equivalent,
which can then be used to generate the documentation.</p>
<h4 id="state-diagrams">State Diagrams</h4>
<p>To generate a state diagram, you use
<code>TransitGraphviz.writeToFile</code> to render a Graphviz
<code>.dot</code> file:</p>
<!-- PD_START:purs
filePath: src/Transit/Render/Graphviz.purs
inline: true
pick:
  - tag: signature_or_foreign
    name: writeToFile
    prefix: '- '
split: true
-->
<ul>
<li><code>writeToFile :: FilePath -&gt; TransitCore -&gt; (Options -&gt; Options) -&gt; Effect Unit</code></li>
</ul>
<p align="right">
<sup
    >üóé <a href="src/Transit/Render/Graphviz.purs#L239-L239"
      >src/Transit/Render/Graphviz.purs L239-L239</a
    > </sup>
</p>
<!-- PD_END -->
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - generateStateDiagram
-->
<div class="sourceCode" id="cb12"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">generateStateDiagram ::</span> <span class="dt">Effect</span> <span class="dt">Unit</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>generateStateDiagram <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    transit ::</span> <span class="dt">TransitCore</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    transit <span class="ot">=</span> reflectType (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">DoorTransit</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  TransitGraphviz.writeToFile <span class="st">&quot;renders/door-light.dot&quot;</span> transit _</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    { theme <span class="ot">=</span> themeHarmonyLight</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  TransitGraphviz.writeToFile <span class="st">&quot;renders/door-dark.dot&quot;</span> transit _</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    { theme <span class="ot">=</span> themeHarmonyDark</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L102-L114"
      >test/Examples/Door.purs L102-L114</a
    > </sup>
</p>
<!-- PD_END -->
<p>The process works in two steps:</p>
<ol type="1">
<li><code>reflectType</code> converts your type-level DSL specification
to a term-level equivalent of type <code>TransitCore</code></li>
<li><code>TransitGraphviz.writeToFile</code> uses that to render a
Graphviz <code>.dot</code> file</li>
</ol>
<p>The <code>writeToFile</code> function accepts an options record that
lets you customize the diagram. E.g. the <code>theme</code> option which
we‚Äôre using above controls the color scheme. <strong>Transit</strong>
provides a couple of built-in themes. But you can also provide your own.
See <a href="docs/themes.md">themes.md</a> for more details.</p>
<p>To convert the <code>.dot</code> file to an SVG (or other formats),
use the Graphviz[^graphviz] command-line tools:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dot</span> <span class="at">-Tsvg</span> renders/door.dot <span class="at">-o</span> renders/door.svg</span></code></pre></div>
<p>Or for PNG:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dot</span> <span class="at">-Tpng</span> renders/door.dot <span class="at">-o</span> renders/door.png</span></code></pre></div>
<h4 id="transition-tables">Transition Tables</h4>
<p>In addition to state diagrams, you can also generate transition
tables from the same specification. This provides a tabular view of all
state transitions, which can be easier to read for some use cases.</p>
<p>The process is identical ‚Äî you use <code>reflectType</code> to
convert your DSL specification, but then use
<code>TransitTable.writeToFile</code> instead:</p>
<!-- PD_START:purs
filePath: test/Examples/Door.purs
pick:
  - generateTransitionTable
-->
<div class="sourceCode" id="cb15"><pre
class="sourceCode purescript"><code class="sourceCode purescript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">generateTransitionTable ::</span> <span class="dt">Effect</span> <span class="dt">Unit</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>generateTransitionTable <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    transit ::</span> <span class="dt">TransitCore</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    transit <span class="ot">=</span> reflectType (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">DoorTransit</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  TransitTable.writeToFile <span class="st">&quot;renders/door.md&quot;</span> transit _</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    { outputFormat <span class="ot">=</span> <span class="dt">TransitTable.Markdown</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p align="right">
<sup
    >üóé <a href="test/Examples/Door.purs#L116-L124"
      >test/Examples/Door.purs L116-L124</a
    > </sup>
</p>
<!-- PD_END -->
<p>This generates a Markdown file containing a table with columns for
‚ÄúFrom State‚Äù, ‚ÄúMessage‚Äù, and ‚ÄúTo State‚Äù.</p>
<p>Since both the state diagram and transition table are generated from
the same DSL specification, they‚Äôre guaranteed to be consistent with
each other and with your type-level specification.</p>
<h3 id="conclusion">Conclusion</h3>
<p>In this example, we‚Äôve seen how <strong>Transit</strong> helps you
build type-safe state machines. We started with a simple door that can
be open or closed, and learned the core workflow:</p>
<ol type="1">
<li><p><strong>Define the state machine</strong> using
<strong>Transit</strong>‚Äôs type-level DSL specification</p></li>
<li><p><strong>Implement the update function</strong> using
<code>mkUpdate</code> with <code>match</code> clauses that the compiler
verifies against the specification</p></li>
<li><p><strong>Generate documentation</strong> automatically ‚Äî both
state diagrams and transition tables ‚Äî from the same
specification</p></li>
</ol>
<p>The key advantage is that your specification, implementation, and
documentation all stay in sync because they share the same source of
truth. The compiler ensures your code matches your specification, and
your documentation is generated directly from it.</p>
<p>While this example was simple, it demonstrates
<strong>Transit</strong>‚Äôs fundamental approach. In the next example,
we‚Äôll see how <strong>Transit</strong> handles more complex scenarios
with states that contain data and conditional
transitions.</p>     </article>
  </body>
</html>
