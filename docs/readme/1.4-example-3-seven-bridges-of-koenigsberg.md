## Example 3: Seven Bridges of KÃ¶nigsberg

So far, we've seen how **Transit** helps you build type-safe state machines and generate state diagrams and transition tables. But the power of **Transit** extends far beyond documentation generation. The reflected data structureâ€”the term-level representation of your type-level DSL specificationâ€”can be converted into a general-purpose graph data structure, enabling sophisticated graph analysis.

This example demonstrates this capability using the famous [Seven Bridges of KÃ¶nigsberg](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg) problem. In 1736, the mathematician Leonhard Euler was asked whether it was possible to walk through the city of KÃ¶nigsberg crossing each of its seven bridges exactly once. Euler's solution to this problem laid the foundation for graph theory.

The problem can be modeled as a graph where:

- **Nodes** represent the four land areas (A, B, C, and D)
- **Edges** represent the seven bridges connecting them

The following picture shows roughly how the actual map looked like back then:

<img src="assets/bridges.png" width="450" />

<img src="assets/bridges-walk.png" width="450" />

Even not immediately obvious, this can be represented as a graph:

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="graphs/bridges-koenigsberg-dark.svg">
  <source media="(prefers-color-scheme: light)" srcset="graphs/bridges-koenigsberg-light.svg">
  <img alt="Seven Bridges of KÃ¶nigsberg graph" src="graphs/bridges-koenigsberg-light.svg">
</picture>

While **Transit** is designed for directed state machines, we can model an undirected graph by defining bidirectional transitions for each bridge. The renderer can then summarize these complementary edges into a single undirected edge for visualization. Notice how each bridge has two transitionsâ€”one in each direction:

<!-- PD_START:purs
filePath: test/Examples/BridgesKoenigsberg.purs
pick:
  - State
  - Msg
-->

```purescript
data State = LandA | LandB | LandC | LandD

data Msg
  = Cross_a
  | Cross_b
  | Cross_c
  | Cross_d
  | Cross_e
  | Cross_f
  | Cross_g
```

<p align="right"><sup>ðŸ—Ž <a href="test/Examples/BridgesKoenigsberg.purs#L36-L45">test/Examples/BridgesKoenigsberg.purs L36-L45</a></sup></p>
<!-- PD_END -->

<!-- PD_START:purs
filePath: test/Examples/BridgesKoenigsberg.purs
pick:
  - BridgesKoenigsbergTransit
-->

```purescript
type BridgesKoenigsbergTransit =
  Transit $ Empty
    :* ("LandA" :@ "Cross_a" >| "LandB")
    :* ("LandB" :@ "Cross_a" >| "LandA")

    :* ("LandA" :@ "Cross_b" >| "LandB")
    :* ("LandB" :@ "Cross_b" >| "LandA")

    :* ("LandA" :@ "Cross_c" >| "LandC")
    :* ("LandC" :@ "Cross_c" >| "LandA")

    :* ("LandA" :@ "Cross_d" >| "LandC")
    :* ("LandC" :@ "Cross_d" >| "LandA")

    :* ("LandA" :@ "Cross_e" >| "LandD")
    :* ("LandD" :@ "Cross_e" >| "LandA")

    :* ("LandB" :@ "Cross_f" >| "LandD")
    :* ("LandD" :@ "Cross_f" >| "LandB")

    :* ("LandC" :@ "Cross_g" >| "LandD")
    :* ("LandD" :@ "Cross_g" >| "LandC")
```

<p align="right"><sup>ðŸ—Ž <a href="test/Examples/BridgesKoenigsberg.purs#L77-L98">test/Examples/BridgesKoenigsberg.purs L77-L98</a></sup></p>
<!-- PD_END -->

<!-- PD_START:purs
filePath: test/Examples/BridgesKoenigsberg.purs
pick:
  - update
-->

```purescript
update :: State -> Msg -> State
update = mkUpdateGeneric @BridgesKoenigsbergTransit
  (match @"LandA" @"Cross_a" \_ _ -> return @"LandB")
  (match @"LandB" @"Cross_a" \_ _ -> return @"LandA")

  (match @"LandA" @"Cross_b" \_ _ -> return @"LandB")
  (match @"LandB" @"Cross_b" \_ _ -> return @"LandA")

  (match @"LandA" @"Cross_c" \_ _ -> return @"LandC")
  (match @"LandC" @"Cross_c" \_ _ -> return @"LandA")

  (match @"LandA" @"Cross_d" \_ _ -> return @"LandC")
  (match @"LandC" @"Cross_d" \_ _ -> return @"LandA")

  (match @"LandA" @"Cross_e" \_ _ -> return @"LandD")
  (match @"LandD" @"Cross_e" \_ _ -> return @"LandA")

  (match @"LandB" @"Cross_f" \_ _ -> return @"LandD")
  (match @"LandD" @"Cross_f" \_ _ -> return @"LandB")

  (match @"LandC" @"Cross_g" \_ _ -> return @"LandD")
  (match @"LandD" @"Cross_g" \_ _ -> return @"LandC")
```

<p align="right"><sup>ðŸ—Ž <a href="test/Examples/BridgesKoenigsberg.purs#L100-L121">test/Examples/BridgesKoenigsberg.purs L100-L121</a></sup></p>
<!-- PD_END -->

<!-- PD_START:purs
filePath: test/Examples/BridgesKoenigsberg.purs
pick:
  - assert1
-->

```purescript
assert1 :: Aff Unit
assert1 =
  for_ [ updateClassic, update ] \fn ->
    assertWalk fn
      LandA
      [ Cross_a /\ LandB
      , Cross_f /\ LandD
      , Cross_g /\ LandC
      , Cross_c /\ LandA
      , Cross_e /\ LandD
      , Cross_g /\ LandC
      , Cross_d /\ LandA
      , Cross_b /\ LandB
      ]
```

<p align="right"><sup>ðŸ—Ž <a href="test/Examples/BridgesKoenigsberg.purs#L127-L140">test/Examples/BridgesKoenigsberg.purs L127-L140</a></sup></p>
<!-- PD_END -->

<!-- PD_START:raw
filePath: graphs/bridges-koenigsberg.html
--><table><thead><tr><th>From State</th><th /><th>Transition</th><th /><th>To State</th></tr></thead><tbody><tr><td>LandB</td><td>âŸµ</td><td>Cross_a</td><td>âŸ¶</td><td>LandA</td></tr></tbody><tbody><tr><td>LandB</td><td>âŸµ</td><td>Cross_b</td><td>âŸ¶</td><td>LandA</td></tr></tbody><tbody><tr><td>LandC</td><td>âŸµ</td><td>Cross_c</td><td>âŸ¶</td><td>LandA</td></tr></tbody><tbody><tr><td>LandC</td><td>âŸµ</td><td>Cross_d</td><td>âŸ¶</td><td>LandA</td></tr></tbody><tbody><tr><td>LandD</td><td>âŸµ</td><td>Cross_e</td><td>âŸ¶</td><td>LandA</td></tr></tbody><tbody><tr><td>LandD</td><td>âŸµ</td><td>Cross_f</td><td>âŸ¶</td><td>LandB</td></tr></tbody><tbody><tr><td>LandD</td><td>âŸµ</td><td>Cross_g</td><td>âŸ¶</td><td>LandC</td></tr></tbody></table><!-- PD_END -->

The transition table shows the undirected nature of the graphâ€”each bridge can be crossed in both directions. When generating the visualization, the renderer summarizes these bidirectional edges into a single undirected edge:
