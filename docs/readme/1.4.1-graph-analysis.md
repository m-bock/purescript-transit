### Graph Analysis

The real power of **Transit** becomes apparent when we convert the reflected data structure into a general-purpose graph. Using `mkStateGraph`, we transform the **Transit** specification into a `StateGraph`‚Äîa specialized `Graph` type configured with edge and node labels suitable for state machine analysis.

Once we have this graph data structure, we can perform sophisticated analysis using standard graph algorithms. For the Seven Bridges problem, we want to determine if the graph has an **Eulerian circuit** (a path that visits every edge exactly once and returns to the starting point) or an **Eulerian trail** (a path that visits every edge exactly once but doesn't necessarily return to the start).

Euler's theorem states that:

- An undirected graph has an Eulerian trail if and only if it is connected and has exactly zero or two vertices of odd degree

We can check these conditions using helper functions from the `Test.Examples.Common` module:

<!-- PD_START:purs
filePath: test/Examples/Common.purs
pick:
  - nodeDegree
-->

```purescript
nodeDegree :: StateNode -> StateGraph -> Int
nodeDegree state graph = Set.size (Graph.getOutgoingEdges state graph)
```

<p align="right"><sup>üóé <a href="test/Examples/Common.purs#L18-L19">test/Examples/Common.purs L18-L19</a></sup></p>
<!-- PD_END -->

<!-- PD_START:purs
filePath: test/Examples/Common.purs
pick:
  - hasEulerTrail
-->

```purescript
hasEulerTrail :: StateGraph -> Boolean
hasEulerTrail graph =
  let
    nodes :: Array StateNode
    nodes = fromFoldable (Graph.getNodes graph)

    countEdgesByNode :: Array Int
    countEdgesByNode = map (\node -> Set.size (Graph.getOutgoingEdges node graph)) nodes

    sumOddEdges :: Int
    sumOddEdges = (Array.length <<< Array.filter Int.odd) countEdgesByNode
  in
    sumOddEdges == 2 || sumOddEdges == 0
```

<p align="right"><sup>üóé <a href="test/Examples/Common.purs#L21-L33">test/Examples/Common.purs L21-L33</a></sup></p>
<!-- PD_END -->

To perform the analysis, we convert the reflected **Transit** specification into a graph and then check its properties:

<!-- PD_START:purs
filePath: test/Examples/BridgesKoenigsberg.purs
pick:
  - spec
  - main
-->

```purescript
spec :: Spec Unit
spec = do
  describe ".." do
    it "should assert1" do
      assert1
      assert2

main :: Effect Unit
main = do
  let
    transit = reflectType (Proxy @BridgesKoenigsbergTransit)

  for_
    [ { theme: themeHarmonyLight, file: "graphs/bridges-koenigsberg-light.dot" }
    , { theme: themeHarmonyDark, file: "graphs/bridges-koenigsberg-dark.dot" }
    ]
    \opts ->
      TransitGraphviz.writeToFile opts.file transit _
        { useUndirectedEdges = true
        , theme = opts.theme
        }

  TransitTable.writeToFile "graphs/bridges-koenigsberg.html" transit _
    { useUndirectedEdges = true }
```

<p align="right"><sup>üóé <a href="test/Examples/BridgesKoenigsberg.purs#L152-L179">test/Examples/BridgesKoenigsberg.purs L152-L179</a></sup></p>
<!-- PD_END -->

The key steps are:

1. **Reflect the type-level specification**: `reflectType (Proxy @BridgesKoenigsbergTransit)` converts the type-level DSL to a term-level representation
2. **Convert to a graph**: `mkStateGraph transit` transforms the **Transit** specification into a `StateGraph`‚Äîa general-purpose graph data structure
3. **Perform analysis**: Use graph analysis functions like `hasEulerCircle` and `hasEulerTrail` to check properties

<!-- PD_START:purs
filePath: test/Examples/Common.purs
pick:
  - nodeDegree
-->

```purescript
nodeDegree :: StateNode -> StateGraph -> Int
nodeDegree state graph = Set.size (Graph.getOutgoingEdges state graph)
```

<p align="right"><sup>üóé <a href="test/Examples/Common.purs#L18-L19">test/Examples/Common.purs L18-L19</a></sup></p>
<!-- PD_END -->

<!-- PD_START:purs
filePath: test/Examples/Common.purs
pick:
  - hasEulerTrail
-->

```purescript
hasEulerTrail :: StateGraph -> Boolean
hasEulerTrail graph =
  let
    nodes :: Array StateNode
    nodes = fromFoldable (Graph.getNodes graph)

    countEdgesByNode :: Array Int
    countEdgesByNode = map (\node -> Set.size (Graph.getOutgoingEdges node graph)) nodes

    sumOddEdges :: Int
    sumOddEdges = (Array.length <<< Array.filter Int.odd) countEdgesByNode
  in
    sumOddEdges == 2 || sumOddEdges == 0
```

<p align="right"><sup>üóé <a href="test/Examples/Common.purs#L21-L33">test/Examples/Common.purs L21-L33</a></sup></p>
<!-- PD_END -->

<!-- PD_START:purs
filePath: test/Examples/BridgesKoenigsberg.purs
pick:
  - assert1
-->

```purescript
assert1 :: Aff Unit
assert1 =
  for_ [ updateClassic, update ] \fn ->
    assertWalk fn
      LandA
      [ Cross_a /\ LandB
      , Cross_f /\ LandD
      , Cross_g /\ LandC
      , Cross_c /\ LandA
      , Cross_e /\ LandD
      , Cross_g /\ LandC
      , Cross_d /\ LandA
      , Cross_b /\ LandB
      ]
```

<p align="right"><sup>üóé <a href="test/Examples/BridgesKoenigsberg.purs#L127-L140">test/Examples/BridgesKoenigsberg.purs L127-L140</a></sup></p>
<!-- PD_END -->

<!-- PD_START:purs
filePath: test/Examples/BridgesKoenigsberg.purs
pick:
  - assert2
-->

```purescript
assert2 :: Aff Unit
assert2 = do
  hasEulerTrail graph `shouldEqual` false
```

<p align="right"><sup>üóé <a href="test/Examples/BridgesKoenigsberg.purs#L148-L150">test/Examples/BridgesKoenigsberg.purs L148-L150</a></sup></p>
<!-- PD_END -->

These functions check whether the graph is undirected and count how many vertices have an odd number of outgoing edges. For the Seven Bridges of K√∂nigsberg:

- **LandA** has 5 bridges (odd)
- **LandB** has 3 bridges (odd)
- **LandC** has 3 bridges (odd)
- **LandD** has 3 bridges (odd)

Since all four vertices have an odd degree, the graph has **4 vertices with odd degree**. According to Euler's theorem, this means:

- ‚ùå The graph does **not** have an Eulerian circuit (would require 0 odd-degree vertices)
- ‚ùå The graph does **not** have an Eulerian trail (would require 0 or 2 odd-degree vertices)

This confirms Euler's original conclusion: it's impossible to walk through K√∂nigsberg crossing each bridge exactly once.

This example demonstrates that **Transit**'s value extends far beyond state machine documentation. By reflecting the type-level specification to a term-level graph data structure, you gain access to a rich ecosystem of graph algorithms and analysis tools. The same DSL that ensures compile-time correctness for your state transitions can also power runtime graph analysis, pathfinding, cycle detection, and more.

In the next example, we'll see a graph that **does** have an Eulerian trail, demonstrating how **Transit** can help verify and understand graph properties beyond simple state machines.
